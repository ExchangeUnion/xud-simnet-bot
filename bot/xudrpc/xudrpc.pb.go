// Code generated by protoc-gen-go. DO NOT EDIT.
// source: xudrpc.proto

/*
Package xudrpc is a generated protocol buffer package.

It is generated from these files:
	xudrpc.proto

It has these top-level messages:
	ChannelBalanceRequest
	ChannelBalanceResponse
	CancelOrderRequest
	CancelOrderResponse
	ConnectRequest
	ConnectResponse
	DisconnectRequest
	DisconnectResponse
	ExecuteSwapRequest
	ExecuteSwapResponse
	GetInfoRequest
	GetInfoResponse
	GetOrdersRequest
	GetOrdersResponse
	GetPairsRequest
	GetPairsResponse
	ListPeersRequest
	ListPeersResponse
	LndChannels
	LndInfo
	Order
	Orders
	OrderMatch
	OrdersCount
	Pair
	Peer
	PlaceOrderRequest
	PlaceOrderResponse
	RaidenInfo
	SwapPayload
	ShutdownRequest
	ShutdownResponse
	SubscribePeerOrdersRequest
	SubscribePeerOrdersResponse
	SubscribeSwapsRequest
	SubscribeSwapsResponse
*/
package xudrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ChannelBalanceRequest struct {
	// The ticker symbol of the currency to query for
	Currency string `protobuf:"bytes,1,opt,name=currency" json:"currency,omitempty"`
}

func (m *ChannelBalanceRequest) Reset()                    { *m = ChannelBalanceRequest{} }
func (m *ChannelBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceRequest) ProtoMessage()               {}
func (*ChannelBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ChannelBalanceRequest) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type ChannelBalanceResponse struct {
	// Sum of channels balances denominated in satoshis or equivalent
	Balance int64 `protobuf:"varint,1,opt,name=balance" json:"balance,omitempty"`
	// Sum of channels pending balances denominated in satoshis or equivalent
	PendingOpenBalance int64 `protobuf:"varint,2,opt,name=pending_open_balance" json:"pending_open_balance,omitempty"`
}

func (m *ChannelBalanceResponse) Reset()                    { *m = ChannelBalanceResponse{} }
func (m *ChannelBalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*ChannelBalanceResponse) ProtoMessage()               {}
func (*ChannelBalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ChannelBalanceResponse) GetBalance() int64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *ChannelBalanceResponse) GetPendingOpenBalance() int64 {
	if m != nil {
		return m.PendingOpenBalance
	}
	return 0
}

type CancelOrderRequest struct {
	// The local id of the order to cancel
	OrderId string `protobuf:"bytes,1,opt,name=order_id" json:"order_id,omitempty"`
	// The trading pair that the order to cancel is for
	PairId string `protobuf:"bytes,2,opt,name=pair_id" json:"pair_id,omitempty"`
}

func (m *CancelOrderRequest) Reset()                    { *m = CancelOrderRequest{} }
func (m *CancelOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelOrderRequest) ProtoMessage()               {}
func (*CancelOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CancelOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *CancelOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

type CancelOrderResponse struct {
	// Indicates whether an order was successfully canceled
	Canceled bool `protobuf:"varint,1,opt,name=canceled" json:"canceled,omitempty"`
}

func (m *CancelOrderResponse) Reset()                    { *m = CancelOrderResponse{} }
func (m *CancelOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*CancelOrderResponse) ProtoMessage()               {}
func (*CancelOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CancelOrderResponse) GetCanceled() bool {
	if m != nil {
		return m.Canceled
	}
	return false
}

type ConnectRequest struct {
	NodeUri string `protobuf:"bytes,1,opt,name=node_uri" json:"node_uri,omitempty"`
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ConnectRequest) GetNodeUri() string {
	if m != nil {
		return m.NodeUri
	}
	return ""
}

type ConnectResponse struct {
	// A message describing the result of the connection request
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *ConnectResponse) Reset()                    { *m = ConnectResponse{} }
func (m *ConnectResponse) String() string            { return proto.CompactTextString(m) }
func (*ConnectResponse) ProtoMessage()               {}
func (*ConnectResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ConnectResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type DisconnectRequest struct {
	NodePubKey string `protobuf:"bytes,1,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *DisconnectRequest) Reset()                    { *m = DisconnectRequest{} }
func (m *DisconnectRequest) String() string            { return proto.CompactTextString(m) }
func (*DisconnectRequest) ProtoMessage()               {}
func (*DisconnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DisconnectRequest) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type DisconnectResponse struct {
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *DisconnectResponse) Reset()                    { *m = DisconnectResponse{} }
func (m *DisconnectResponse) String() string            { return proto.CompactTextString(m) }
func (*DisconnectResponse) ProtoMessage()               {}
func (*DisconnectResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DisconnectResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type ExecuteSwapRequest struct {
	TargetAddress string       `protobuf:"bytes,1,opt,name=target_address" json:"target_address,omitempty"`
	Payload       *SwapPayload `protobuf:"bytes,2,opt,name=payload" json:"payload,omitempty"`
}

func (m *ExecuteSwapRequest) Reset()                    { *m = ExecuteSwapRequest{} }
func (m *ExecuteSwapRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecuteSwapRequest) ProtoMessage()               {}
func (*ExecuteSwapRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ExecuteSwapRequest) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *ExecuteSwapRequest) GetPayload() *SwapPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ExecuteSwapResponse struct {
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *ExecuteSwapResponse) Reset()                    { *m = ExecuteSwapResponse{} }
func (m *ExecuteSwapResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecuteSwapResponse) ProtoMessage()               {}
func (*ExecuteSwapResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ExecuteSwapResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type GetInfoResponse struct {
	Version    string       `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	NodePubKey string       `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	Uris       []string     `protobuf:"bytes,3,rep,name=uris" json:"uris,omitempty"`
	NumPeers   int32        `protobuf:"varint,4,opt,name=num_peers" json:"num_peers,omitempty"`
	NumPairs   int32        `protobuf:"varint,5,opt,name=num_pairs" json:"num_pairs,omitempty"`
	Orders     *OrdersCount `protobuf:"bytes,6,opt,name=orders" json:"orders,omitempty"`
	Lndbtc     *LndInfo     `protobuf:"bytes,7,opt,name=lndbtc" json:"lndbtc,omitempty"`
	Lndltc     *LndInfo     `protobuf:"bytes,8,opt,name=lndltc" json:"lndltc,omitempty"`
	Raiden     *RaidenInfo  `protobuf:"bytes,9,opt,name=raiden" json:"raiden,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetInfoResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GetInfoResponse) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *GetInfoResponse) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *GetInfoResponse) GetNumPeers() int32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *GetInfoResponse) GetNumPairs() int32 {
	if m != nil {
		return m.NumPairs
	}
	return 0
}

func (m *GetInfoResponse) GetOrders() *OrdersCount {
	if m != nil {
		return m.Orders
	}
	return nil
}

func (m *GetInfoResponse) GetLndbtc() *LndInfo {
	if m != nil {
		return m.Lndbtc
	}
	return nil
}

func (m *GetInfoResponse) GetLndltc() *LndInfo {
	if m != nil {
		return m.Lndltc
	}
	return nil
}

func (m *GetInfoResponse) GetRaiden() *RaidenInfo {
	if m != nil {
		return m.Raiden
	}
	return nil
}

type GetOrdersRequest struct {
	// The trading pair for which to retrieve orders
	PairId string `protobuf:"bytes,1,opt,name=pair_id" json:"pair_id,omitempty"`
	// The maximum number of orders to return from either side of the order book
	MaxResults uint32 `protobuf:"varint,2,opt,name=max_results" json:"max_results,omitempty"`
}

func (m *GetOrdersRequest) Reset()                    { *m = GetOrdersRequest{} }
func (m *GetOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*GetOrdersRequest) ProtoMessage()               {}
func (*GetOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetOrdersRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *GetOrdersRequest) GetMaxResults() uint32 {
	if m != nil {
		return m.MaxResults
	}
	return 0
}

type GetOrdersResponse struct {
	// A list of peer orders
	PeerOrders *Orders `protobuf:"bytes,1,opt,name=peer_orders" json:"peer_orders,omitempty"`
	// A list of orders placed locally
	OwnOrders *Orders `protobuf:"bytes,2,opt,name=own_orders" json:"own_orders,omitempty"`
}

func (m *GetOrdersResponse) Reset()                    { *m = GetOrdersResponse{} }
func (m *GetOrdersResponse) String() string            { return proto.CompactTextString(m) }
func (*GetOrdersResponse) ProtoMessage()               {}
func (*GetOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetOrdersResponse) GetPeerOrders() *Orders {
	if m != nil {
		return m.PeerOrders
	}
	return nil
}

func (m *GetOrdersResponse) GetOwnOrders() *Orders {
	if m != nil {
		return m.OwnOrders
	}
	return nil
}

type GetPairsRequest struct {
}

func (m *GetPairsRequest) Reset()                    { *m = GetPairsRequest{} }
func (m *GetPairsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetPairsRequest) ProtoMessage()               {}
func (*GetPairsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type GetPairsResponse struct {
	Pairs []*Pair `protobuf:"bytes,1,rep,name=pairs" json:"pairs,omitempty"`
}

func (m *GetPairsResponse) Reset()                    { *m = GetPairsResponse{} }
func (m *GetPairsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetPairsResponse) ProtoMessage()               {}
func (*GetPairsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetPairsResponse) GetPairs() []*Pair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type ListPeersRequest struct {
}

func (m *ListPeersRequest) Reset()                    { *m = ListPeersRequest{} }
func (m *ListPeersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPeersRequest) ProtoMessage()               {}
func (*ListPeersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type ListPeersResponse struct {
	Peers []*Peer `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *ListPeersResponse) Reset()                    { *m = ListPeersResponse{} }
func (m *ListPeersResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPeersResponse) ProtoMessage()               {}
func (*ListPeersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListPeersResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type LndChannels struct {
	Active   int32 `protobuf:"varint,1,opt,name=active" json:"active,omitempty"`
	Inactive int32 `protobuf:"varint,2,opt,name=inactive" json:"inactive,omitempty"`
	Pending  int32 `protobuf:"varint,3,opt,name=pending" json:"pending,omitempty"`
}

func (m *LndChannels) Reset()                    { *m = LndChannels{} }
func (m *LndChannels) String() string            { return proto.CompactTextString(m) }
func (*LndChannels) ProtoMessage()               {}
func (*LndChannels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *LndChannels) GetActive() int32 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *LndChannels) GetInactive() int32 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *LndChannels) GetPending() int32 {
	if m != nil {
		return m.Pending
	}
	return 0
}

type LndInfo struct {
	Error       string       `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Channels    *LndChannels `protobuf:"bytes,2,opt,name=channels" json:"channels,omitempty"`
	Chains      []string     `protobuf:"bytes,3,rep,name=chains" json:"chains,omitempty"`
	Blockheight int32        `protobuf:"varint,4,opt,name=blockheight" json:"blockheight,omitempty"`
	Uris        []string     `protobuf:"bytes,5,rep,name=uris" json:"uris,omitempty"`
	Version     string       `protobuf:"bytes,6,opt,name=version" json:"version,omitempty"`
}

func (m *LndInfo) Reset()                    { *m = LndInfo{} }
func (m *LndInfo) String() string            { return proto.CompactTextString(m) }
func (*LndInfo) ProtoMessage()               {}
func (*LndInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LndInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *LndInfo) GetChannels() *LndChannels {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *LndInfo) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

func (m *LndInfo) GetBlockheight() int32 {
	if m != nil {
		return m.Blockheight
	}
	return 0
}

func (m *LndInfo) GetUris() []string {
	if m != nil {
		return m.Uris
	}
	return nil
}

func (m *LndInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type Order struct {
	// The price of the order, precise to 6 decimal places.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order, precise to 6 decimal places.
	Quantity float64 `protobuf:"fixed64,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that this order is for
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The node pub key of the peer that created this order
	PeerPubKey string `protobuf:"bytes,4,opt,name=peer_pub_key,json=peer_id" json:"peer_pub_key,omitempty"`
	// A UUID for this order
	Id string `protobuf:"bytes,5,opt,name=id" json:"id,omitempty"`
	// The local id for this order
	LocalId string `protobuf:"bytes,6,opt,name=local_id" json:"local_id,omitempty"`
	// The epoch time when this order was created
	CreatedAt int64 `protobuf:"varint,7,opt,name=created_at" json:"created_at,omitempty"`
	// Lightning invoice
	Invoice string `protobuf:"bytes,8,opt,name=invoice" json:"invoice,omitempty"`
	// Indicates whether an order was canceled
	Canceled bool `protobuf:"varint,9,opt,name=canceled" json:"canceled,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Order) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Order) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *Order) GetPeerPubKey() string {
	if m != nil {
		return m.PeerPubKey
	}
	return ""
}

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Order) GetLocalId() string {
	if m != nil {
		return m.LocalId
	}
	return ""
}

func (m *Order) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Order) GetInvoice() string {
	if m != nil {
		return m.Invoice
	}
	return ""
}

func (m *Order) GetCanceled() bool {
	if m != nil {
		return m.Canceled
	}
	return false
}

type Orders struct {
	// A list of buy orders sorted by descending price
	BuyOrders []*Order `protobuf:"bytes,1,rep,name=buy_orders" json:"buy_orders,omitempty"`
	// A list of sell orders sorted by ascending price
	SellOrders []*Order `protobuf:"bytes,2,rep,name=sell_orders" json:"sell_orders,omitempty"`
}

func (m *Orders) Reset()                    { *m = Orders{} }
func (m *Orders) String() string            { return proto.CompactTextString(m) }
func (*Orders) ProtoMessage()               {}
func (*Orders) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Orders) GetBuyOrders() []*Order {
	if m != nil {
		return m.BuyOrders
	}
	return nil
}

func (m *Orders) GetSellOrders() []*Order {
	if m != nil {
		return m.SellOrders
	}
	return nil
}

type OrderMatch struct {
	Maker *Order `protobuf:"bytes,1,opt,name=maker" json:"maker,omitempty"`
	Taker *Order `protobuf:"bytes,2,opt,name=taker" json:"taker,omitempty"`
}

func (m *OrderMatch) Reset()                    { *m = OrderMatch{} }
func (m *OrderMatch) String() string            { return proto.CompactTextString(m) }
func (*OrderMatch) ProtoMessage()               {}
func (*OrderMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *OrderMatch) GetMaker() *Order {
	if m != nil {
		return m.Maker
	}
	return nil
}

func (m *OrderMatch) GetTaker() *Order {
	if m != nil {
		return m.Taker
	}
	return nil
}

type OrdersCount struct {
	Peer int32 `protobuf:"varint,1,opt,name=peer" json:"peer,omitempty"`
	Own  int32 `protobuf:"varint,2,opt,name=own" json:"own,omitempty"`
}

func (m *OrdersCount) Reset()                    { *m = OrdersCount{} }
func (m *OrdersCount) String() string            { return proto.CompactTextString(m) }
func (*OrdersCount) ProtoMessage()               {}
func (*OrdersCount) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *OrdersCount) GetPeer() int32 {
	if m != nil {
		return m.Peer
	}
	return 0
}

func (m *OrdersCount) GetOwn() int32 {
	if m != nil {
		return m.Own
	}
	return 0
}

type Pair struct {
	Id            string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	BaseCurrency  string `protobuf:"bytes,2,opt,name=base_currency" json:"base_currency,omitempty"`
	QuoteCurrency string `protobuf:"bytes,3,opt,name=quote_currency" json:"quote_currency,omitempty"`
	SwapProtocol  string `protobuf:"bytes,4,opt,name=swap_protocol" json:"swap_protocol,omitempty"`
}

func (m *Pair) Reset()                    { *m = Pair{} }
func (m *Pair) String() string            { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()               {}
func (*Pair) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *Pair) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pair) GetBaseCurrency() string {
	if m != nil {
		return m.BaseCurrency
	}
	return ""
}

func (m *Pair) GetQuoteCurrency() string {
	if m != nil {
		return m.QuoteCurrency
	}
	return ""
}

func (m *Pair) GetSwapProtocol() string {
	if m != nil {
		return m.SwapProtocol
	}
	return ""
}

type Peer struct {
	// The socket address with host and port for this peer
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// The node pub key to uniquely identify this peer
	NodePubKey string `protobuf:"bytes,2,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
	// Indicates whether this peer was connected inbound
	Inbound bool `protobuf:"varint,3,opt,name=inbound" json:"inbound,omitempty"`
	// A list of trading pair tickers supported by this peer
	Pairs []string `protobuf:"bytes,4,rep,name=pairs" json:"pairs,omitempty"`
	// The version of xud being used by the peer
	XudVersion string `protobuf:"bytes,5,opt,name=xud_version" json:"xud_version,omitempty"`
	// The time in seconds that we have been connected to this peer
	SecondsConnected int32 `protobuf:"varint,6,opt,name=seconds_connected" json:"seconds_connected,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *Peer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Peer) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

func (m *Peer) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *Peer) GetPairs() []string {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func (m *Peer) GetXudVersion() string {
	if m != nil {
		return m.XudVersion
	}
	return ""
}

func (m *Peer) GetSecondsConnected() int32 {
	if m != nil {
		return m.SecondsConnected
	}
	return 0
}

type PlaceOrderRequest struct {
	// The price of the order, precise to 6 decimal places.
	Price float64 `protobuf:"fixed64,1,opt,name=price" json:"price,omitempty"`
	// The quantity of the order, precise to 6 decimal places.
	Quantity float64 `protobuf:"fixed64,2,opt,name=quantity" json:"quantity,omitempty"`
	// The trading pair that the order is for
	PairId string `protobuf:"bytes,3,opt,name=pair_id" json:"pair_id,omitempty"`
	// The local id to assign to the order
	OrderId string `protobuf:"bytes,4,opt,name=order_id" json:"order_id,omitempty"`
}

func (m *PlaceOrderRequest) Reset()                    { *m = PlaceOrderRequest{} }
func (m *PlaceOrderRequest) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderRequest) ProtoMessage()               {}
func (*PlaceOrderRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *PlaceOrderRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *PlaceOrderRequest) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *PlaceOrderRequest) GetPairId() string {
	if m != nil {
		return m.PairId
	}
	return ""
}

func (m *PlaceOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

type PlaceOrderResponse struct {
	// A list of orders matching the newly placed order
	Matches []*OrderMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	// The remaining portion of the order, after matches, that enters the order book
	RemainingOrder *Order `protobuf:"bytes,2,opt,name=remaining_order" json:"remaining_order,omitempty"`
}

func (m *PlaceOrderResponse) Reset()                    { *m = PlaceOrderResponse{} }
func (m *PlaceOrderResponse) String() string            { return proto.CompactTextString(m) }
func (*PlaceOrderResponse) ProtoMessage()               {}
func (*PlaceOrderResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *PlaceOrderResponse) GetMatches() []*OrderMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

func (m *PlaceOrderResponse) GetRemainingOrder() *Order {
	if m != nil {
		return m.RemainingOrder
	}
	return nil
}

type RaidenInfo struct {
	Error    string `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Address  string `protobuf:"bytes,2,opt,name=address" json:"address,omitempty"`
	Channels int32  `protobuf:"varint,3,opt,name=channels" json:"channels,omitempty"`
	Version  string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
}

func (m *RaidenInfo) Reset()                    { *m = RaidenInfo{} }
func (m *RaidenInfo) String() string            { return proto.CompactTextString(m) }
func (*RaidenInfo) ProtoMessage()               {}
func (*RaidenInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *RaidenInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RaidenInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaidenInfo) GetChannels() int32 {
	if m != nil {
		return m.Channels
	}
	return 0
}

func (m *RaidenInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type SwapPayload struct {
	Role            string `protobuf:"bytes,1,opt,name=role" json:"role,omitempty"`
	SendingAmount   uint64 `protobuf:"varint,2,opt,name=sending_amount" json:"sending_amount,omitempty"`
	SendingToken    string `protobuf:"bytes,3,opt,name=sending_token" json:"sending_token,omitempty"`
	ReceivingAmount uint64 `protobuf:"varint,4,opt,name=receiving_amount" json:"receiving_amount,omitempty"`
	ReceivingToken  string `protobuf:"bytes,5,opt,name=receiving_token" json:"receiving_token,omitempty"`
	NodePubKey      string `protobuf:"bytes,6,opt,name=node_pub_key" json:"node_pub_key,omitempty"`
}

func (m *SwapPayload) Reset()                    { *m = SwapPayload{} }
func (m *SwapPayload) String() string            { return proto.CompactTextString(m) }
func (*SwapPayload) ProtoMessage()               {}
func (*SwapPayload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *SwapPayload) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SwapPayload) GetSendingAmount() uint64 {
	if m != nil {
		return m.SendingAmount
	}
	return 0
}

func (m *SwapPayload) GetSendingToken() string {
	if m != nil {
		return m.SendingToken
	}
	return ""
}

func (m *SwapPayload) GetReceivingAmount() uint64 {
	if m != nil {
		return m.ReceivingAmount
	}
	return 0
}

func (m *SwapPayload) GetReceivingToken() string {
	if m != nil {
		return m.ReceivingToken
	}
	return ""
}

func (m *SwapPayload) GetNodePubKey() string {
	if m != nil {
		return m.NodePubKey
	}
	return ""
}

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

type ShutdownResponse struct {
	// A message describing the result of the shutdown request
	Result string `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *ShutdownResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

type SubscribePeerOrdersRequest struct {
}

func (m *SubscribePeerOrdersRequest) Reset()                    { *m = SubscribePeerOrdersRequest{} }
func (m *SubscribePeerOrdersRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribePeerOrdersRequest) ProtoMessage()               {}
func (*SubscribePeerOrdersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

type SubscribePeerOrdersResponse struct {
	Order *Order `protobuf:"bytes,1,opt,name=order" json:"order,omitempty"`
}

func (m *SubscribePeerOrdersResponse) Reset()                    { *m = SubscribePeerOrdersResponse{} }
func (m *SubscribePeerOrdersResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscribePeerOrdersResponse) ProtoMessage()               {}
func (*SubscribePeerOrdersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *SubscribePeerOrdersResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type SubscribeSwapsRequest struct {
}

func (m *SubscribeSwapsRequest) Reset()                    { *m = SubscribeSwapsRequest{} }
func (m *SubscribeSwapsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeSwapsRequest) ProtoMessage()               {}
func (*SubscribeSwapsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

type SubscribeSwapsResponse struct {
	// The order which was executed for the swap with updated remaining quantity
	Order string `protobuf:"bytes,1,opt,name=order" json:"order,omitempty"`
}

func (m *SubscribeSwapsResponse) Reset()                    { *m = SubscribeSwapsResponse{} }
func (m *SubscribeSwapsResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscribeSwapsResponse) ProtoMessage()               {}
func (*SubscribeSwapsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *SubscribeSwapsResponse) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func init() {
	proto.RegisterType((*ChannelBalanceRequest)(nil), "xudrpc.ChannelBalanceRequest")
	proto.RegisterType((*ChannelBalanceResponse)(nil), "xudrpc.ChannelBalanceResponse")
	proto.RegisterType((*CancelOrderRequest)(nil), "xudrpc.CancelOrderRequest")
	proto.RegisterType((*CancelOrderResponse)(nil), "xudrpc.CancelOrderResponse")
	proto.RegisterType((*ConnectRequest)(nil), "xudrpc.ConnectRequest")
	proto.RegisterType((*ConnectResponse)(nil), "xudrpc.ConnectResponse")
	proto.RegisterType((*DisconnectRequest)(nil), "xudrpc.DisconnectRequest")
	proto.RegisterType((*DisconnectResponse)(nil), "xudrpc.DisconnectResponse")
	proto.RegisterType((*ExecuteSwapRequest)(nil), "xudrpc.ExecuteSwapRequest")
	proto.RegisterType((*ExecuteSwapResponse)(nil), "xudrpc.ExecuteSwapResponse")
	proto.RegisterType((*GetInfoRequest)(nil), "xudrpc.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "xudrpc.GetInfoResponse")
	proto.RegisterType((*GetOrdersRequest)(nil), "xudrpc.GetOrdersRequest")
	proto.RegisterType((*GetOrdersResponse)(nil), "xudrpc.GetOrdersResponse")
	proto.RegisterType((*GetPairsRequest)(nil), "xudrpc.GetPairsRequest")
	proto.RegisterType((*GetPairsResponse)(nil), "xudrpc.GetPairsResponse")
	proto.RegisterType((*ListPeersRequest)(nil), "xudrpc.ListPeersRequest")
	proto.RegisterType((*ListPeersResponse)(nil), "xudrpc.ListPeersResponse")
	proto.RegisterType((*LndChannels)(nil), "xudrpc.LndChannels")
	proto.RegisterType((*LndInfo)(nil), "xudrpc.LndInfo")
	proto.RegisterType((*Order)(nil), "xudrpc.Order")
	proto.RegisterType((*Orders)(nil), "xudrpc.Orders")
	proto.RegisterType((*OrderMatch)(nil), "xudrpc.OrderMatch")
	proto.RegisterType((*OrdersCount)(nil), "xudrpc.OrdersCount")
	proto.RegisterType((*Pair)(nil), "xudrpc.Pair")
	proto.RegisterType((*Peer)(nil), "xudrpc.Peer")
	proto.RegisterType((*PlaceOrderRequest)(nil), "xudrpc.PlaceOrderRequest")
	proto.RegisterType((*PlaceOrderResponse)(nil), "xudrpc.PlaceOrderResponse")
	proto.RegisterType((*RaidenInfo)(nil), "xudrpc.RaidenInfo")
	proto.RegisterType((*SwapPayload)(nil), "xudrpc.SwapPayload")
	proto.RegisterType((*ShutdownRequest)(nil), "xudrpc.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "xudrpc.ShutdownResponse")
	proto.RegisterType((*SubscribePeerOrdersRequest)(nil), "xudrpc.SubscribePeerOrdersRequest")
	proto.RegisterType((*SubscribePeerOrdersResponse)(nil), "xudrpc.SubscribePeerOrdersResponse")
	proto.RegisterType((*SubscribeSwapsRequest)(nil), "xudrpc.SubscribeSwapsRequest")
	proto.RegisterType((*SubscribeSwapsResponse)(nil), "xudrpc.SubscribeSwapsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Xud service

type XudClient interface {
	// Cancel placed order from the orderbook.
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error)
	// Get the total balance available across all channels for a given currency.
	ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error)
	// Connect to an XU node.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Disconnect from a connected peer XU node.
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error)
	// Execute an atomic swap
	ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*ExecuteSwapResponse, error)
	// Get general information about this Exchange Union node.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// Get the list of the order book's available pairs.
	GetPairs(ctx context.Context, in *GetPairsRequest, opts ...grpc.CallOption) (*GetPairsResponse, error)
	// Get a list of standing orders from the order book.
	GetOrders(ctx context.Context, in *GetOrdersRequest, opts ...grpc.CallOption) (*GetOrdersResponse, error)
	// Get a list of connected peers.
	ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error)
	// Add an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error)
	// Begin shutting down xud.
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
	// Subscribe to peer order events.
	SubscribePeerOrders(ctx context.Context, in *SubscribePeerOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribePeerOrdersClient, error)
	// Subscribe executed swaps.
	SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error)
}

type xudClient struct {
	cc *grpc.ClientConn
}

func NewXudClient(cc *grpc.ClientConn) XudClient {
	return &xudClient{cc}
}

func (c *xudClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*CancelOrderResponse, error) {
	out := new(CancelOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/CancelOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ChannelBalance(ctx context.Context, in *ChannelBalanceRequest, opts ...grpc.CallOption) (*ChannelBalanceResponse, error) {
	out := new(ChannelBalanceResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ChannelBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	out := new(ConnectResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*DisconnectResponse, error) {
	out := new(DisconnectResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Disconnect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ExecuteSwap(ctx context.Context, in *ExecuteSwapRequest, opts ...grpc.CallOption) (*ExecuteSwapResponse, error) {
	out := new(ExecuteSwapResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ExecuteSwap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetPairs(ctx context.Context, in *GetPairsRequest, opts ...grpc.CallOption) (*GetPairsResponse, error) {
	out := new(GetPairsResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetPairs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) GetOrders(ctx context.Context, in *GetOrdersRequest, opts ...grpc.CallOption) (*GetOrdersResponse, error) {
	out := new(GetOrdersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/GetOrders", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) ListPeers(ctx context.Context, in *ListPeersRequest, opts ...grpc.CallOption) (*ListPeersResponse, error) {
	out := new(ListPeersResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/ListPeers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) PlaceOrder(ctx context.Context, in *PlaceOrderRequest, opts ...grpc.CallOption) (*PlaceOrderResponse, error) {
	out := new(PlaceOrderResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/PlaceOrder", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/xudrpc.Xud/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xudClient) SubscribePeerOrders(ctx context.Context, in *SubscribePeerOrdersRequest, opts ...grpc.CallOption) (Xud_SubscribePeerOrdersClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[0], c.cc, "/xudrpc.Xud/SubscribePeerOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribePeerOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribePeerOrdersClient interface {
	Recv() (*SubscribePeerOrdersResponse, error)
	grpc.ClientStream
}

type xudSubscribePeerOrdersClient struct {
	grpc.ClientStream
}

func (x *xudSubscribePeerOrdersClient) Recv() (*SubscribePeerOrdersResponse, error) {
	m := new(SubscribePeerOrdersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *xudClient) SubscribeSwaps(ctx context.Context, in *SubscribeSwapsRequest, opts ...grpc.CallOption) (Xud_SubscribeSwapsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Xud_serviceDesc.Streams[1], c.cc, "/xudrpc.Xud/SubscribeSwaps", opts...)
	if err != nil {
		return nil, err
	}
	x := &xudSubscribeSwapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Xud_SubscribeSwapsClient interface {
	Recv() (*SubscribeSwapsResponse, error)
	grpc.ClientStream
}

type xudSubscribeSwapsClient struct {
	grpc.ClientStream
}

func (x *xudSubscribeSwapsClient) Recv() (*SubscribeSwapsResponse, error) {
	m := new(SubscribeSwapsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Xud service

type XudServer interface {
	// Cancel placed order from the orderbook.
	CancelOrder(context.Context, *CancelOrderRequest) (*CancelOrderResponse, error)
	// Get the total balance available across all channels for a given currency.
	ChannelBalance(context.Context, *ChannelBalanceRequest) (*ChannelBalanceResponse, error)
	// Connect to an XU node.
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Disconnect from a connected peer XU node.
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectResponse, error)
	// Execute an atomic swap
	ExecuteSwap(context.Context, *ExecuteSwapRequest) (*ExecuteSwapResponse, error)
	// Get general information about this Exchange Union node.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// Get the list of the order book's available pairs.
	GetPairs(context.Context, *GetPairsRequest) (*GetPairsResponse, error)
	// Get a list of standing orders from the order book.
	GetOrders(context.Context, *GetOrdersRequest) (*GetOrdersResponse, error)
	// Get a list of connected peers.
	ListPeers(context.Context, *ListPeersRequest) (*ListPeersResponse, error)
	// Add an order to the order book.
	// If price is zero or unspecified a market order will get added.
	PlaceOrder(context.Context, *PlaceOrderRequest) (*PlaceOrderResponse, error)
	// Begin shutting down xud.
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
	// Subscribe to peer order events.
	SubscribePeerOrders(*SubscribePeerOrdersRequest, Xud_SubscribePeerOrdersServer) error
	// Subscribe executed swaps.
	SubscribeSwaps(*SubscribeSwapsRequest, Xud_SubscribeSwapsServer) error
}

func RegisterXudServer(s *grpc.Server, srv XudServer) {
	s.RegisterService(&_Xud_serviceDesc, srv)
}

func _Xud_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ChannelBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ChannelBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ChannelBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ChannelBalance(ctx, req.(*ChannelBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ExecuteSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteSwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ExecuteSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ExecuteSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ExecuteSwap(ctx, req.(*ExecuteSwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetPairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetPairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetPairs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetPairs(ctx, req.(*GetPairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_GetOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).GetOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/GetOrders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).GetOrders(ctx, req.(*GetOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_ListPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).ListPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/ListPeers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).ListPeers(ctx, req.(*ListPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_PlaceOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlaceOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).PlaceOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/PlaceOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).PlaceOrder(ctx, req.(*PlaceOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XudServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xudrpc.Xud/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XudServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Xud_SubscribePeerOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribePeerOrdersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribePeerOrders(m, &xudSubscribePeerOrdersServer{stream})
}

type Xud_SubscribePeerOrdersServer interface {
	Send(*SubscribePeerOrdersResponse) error
	grpc.ServerStream
}

type xudSubscribePeerOrdersServer struct {
	grpc.ServerStream
}

func (x *xudSubscribePeerOrdersServer) Send(m *SubscribePeerOrdersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Xud_SubscribeSwaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeSwapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(XudServer).SubscribeSwaps(m, &xudSubscribeSwapsServer{stream})
}

type Xud_SubscribeSwapsServer interface {
	Send(*SubscribeSwapsResponse) error
	grpc.ServerStream
}

type xudSubscribeSwapsServer struct {
	grpc.ServerStream
}

func (x *xudSubscribeSwapsServer) Send(m *SubscribeSwapsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Xud_serviceDesc = grpc.ServiceDesc{
	ServiceName: "xudrpc.Xud",
	HandlerType: (*XudServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelOrder",
			Handler:    _Xud_CancelOrder_Handler,
		},
		{
			MethodName: "ChannelBalance",
			Handler:    _Xud_ChannelBalance_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Xud_Connect_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Xud_Disconnect_Handler,
		},
		{
			MethodName: "ExecuteSwap",
			Handler:    _Xud_ExecuteSwap_Handler,
		},
		{
			MethodName: "GetInfo",
			Handler:    _Xud_GetInfo_Handler,
		},
		{
			MethodName: "GetPairs",
			Handler:    _Xud_GetPairs_Handler,
		},
		{
			MethodName: "GetOrders",
			Handler:    _Xud_GetOrders_Handler,
		},
		{
			MethodName: "ListPeers",
			Handler:    _Xud_ListPeers_Handler,
		},
		{
			MethodName: "PlaceOrder",
			Handler:    _Xud_PlaceOrder_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Xud_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribePeerOrders",
			Handler:       _Xud_SubscribePeerOrders_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeSwaps",
			Handler:       _Xud_SubscribeSwaps_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "xudrpc.proto",
}

func init() { proto.RegisterFile("xudrpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1594 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x06, 0x75, 0xb3, 0x74, 0xe4, 0xc8, 0xd2, 0xd8, 0xb1, 0x65, 0xe5, 0xf2, 0x1b, 0x93, 0x1f,
	0xff, 0xef, 0xba, 0x8e, 0x9d, 0x38, 0x40, 0x03, 0x74, 0x19, 0xb7, 0x08, 0x5a, 0xb8, 0xad, 0x41,
	0x17, 0x41, 0x81, 0x02, 0x11, 0x28, 0x72, 0x12, 0x13, 0xa6, 0x86, 0x0a, 0x2f, 0xb6, 0x83, 0xac,
	0xda, 0x65, 0xb7, 0x7d, 0x99, 0x3e, 0x40, 0x57, 0xdd, 0xf6, 0x15, 0xb2, 0xe9, 0xbe, 0x0f, 0x50,
	0x9c, 0xb9, 0x90, 0x33, 0x14, 0xdd, 0x74, 0xd1, 0x1d, 0xcf, 0x65, 0xbe, 0x73, 0x78, 0x6e, 0x73,
	0x06, 0x56, 0xaf, 0xf3, 0x20, 0x59, 0xf8, 0x07, 0x8b, 0x24, 0xce, 0x62, 0xd2, 0x91, 0xd4, 0x64,
	0xe4, 0x71, 0x1e, 0x67, 0x5e, 0x16, 0xc6, 0x3c, 0x95, 0x22, 0xfa, 0x04, 0x6e, 0x1f, 0x9f, 0x7b,
	0x9c, 0xb3, 0xe8, 0x99, 0x17, 0x79, 0xdc, 0x67, 0x2e, 0x7b, 0x93, 0xb3, 0x34, 0x23, 0x13, 0xe8,
	0xfa, 0x79, 0x92, 0x30, 0xee, 0xbf, 0x1d, 0x3b, 0x3b, 0xce, 0x6e, 0xcf, 0x2d, 0x68, 0xfa, 0x0a,
	0x36, 0xab, 0x87, 0xd2, 0x45, 0xcc, 0x53, 0x46, 0xc6, 0xb0, 0x32, 0x93, 0x2c, 0x71, 0xa8, 0xe9,
	0x6a, 0x92, 0x1c, 0xc1, 0xc6, 0x82, 0xf1, 0x20, 0xe4, 0xaf, 0xa7, 0xf1, 0x82, 0xf1, 0xa9, 0x56,
	0x6b, 0x08, 0xb5, 0x5a, 0x19, 0xfd, 0x12, 0xc8, 0x31, 0x7e, 0x44, 0xdf, 0x24, 0x01, 0x4b, 0x0c,
	0xcf, 0x62, 0xa4, 0xa7, 0x61, 0xa0, 0x3d, 0xd3, 0x34, 0xda, 0x5f, 0x78, 0xa1, 0x10, 0x35, 0x84,
	0x48, 0x93, 0xf4, 0x31, 0xac, 0x5b, 0x58, 0xca, 0x61, 0xfc, 0x4d, 0xc1, 0x66, 0x12, 0xac, 0xeb,
	0x16, 0x34, 0xdd, 0x87, 0xc1, 0x71, 0xcc, 0x39, 0xf3, 0x33, 0xc3, 0x34, 0x8f, 0x03, 0x36, 0xcd,
	0x93, 0x50, 0x9b, 0xd6, 0x34, 0xfd, 0x08, 0xd6, 0x0a, 0x6d, 0x05, 0xbe, 0x09, 0x9d, 0x84, 0xa5,
	0x79, 0x94, 0x29, 0x65, 0x45, 0xd1, 0xa7, 0x30, 0xfa, 0x2c, 0x4c, 0x7d, 0x1b, 0x9b, 0xc2, 0xaa,
	0xc0, 0x5a, 0xe4, 0xb3, 0xe9, 0x05, 0xd3, 0x41, 0xb7, 0x78, 0x74, 0x1f, 0x88, 0x79, 0xf0, 0x03,
	0x66, 0x2e, 0x80, 0x7c, 0x7e, 0xcd, 0xfc, 0x3c, 0x63, 0x67, 0x57, 0xde, 0x42, 0xdb, 0xf9, 0x1f,
	0x0c, 0x32, 0x2f, 0x79, 0xcd, 0xb2, 0xa9, 0x17, 0x04, 0x09, 0x4b, 0x53, 0x75, 0xaa, 0xc2, 0x25,
	0x0f, 0x31, 0x94, 0x6f, 0xa3, 0xd8, 0x93, 0xa1, 0xec, 0x1f, 0xad, 0x1f, 0xa8, 0xa2, 0x42, 0xb4,
	0x53, 0x29, 0x72, 0xb5, 0x0e, 0x7d, 0x08, 0xeb, 0x96, 0xb1, 0x0f, 0xf8, 0x36, 0x84, 0xc1, 0x73,
	0x96, 0x7d, 0xc1, 0x5f, 0xc5, 0xca, 0x2f, 0xfa, 0x5b, 0x03, 0xd6, 0x0a, 0x56, 0x59, 0x4e, 0x97,
	0x2c, 0x49, 0xc3, 0x98, 0xab, 0xe3, 0x9a, 0x5c, 0x8a, 0x56, 0x63, 0x39, 0x5a, 0x84, 0x40, 0x2b,
	0x4f, 0xc2, 0x74, 0xdc, 0xdc, 0x69, 0xee, 0xf6, 0x5c, 0xf1, 0x4d, 0xee, 0x42, 0x8f, 0xe7, 0xf3,
	0xe9, 0x82, 0xb1, 0x24, 0x1d, 0xb7, 0x76, 0x9c, 0xdd, 0xb6, 0x5b, 0x32, 0x0a, 0xa9, 0x17, 0x26,
	0xe9, 0xb8, 0x6d, 0x48, 0x91, 0x41, 0x3e, 0x86, 0x8e, 0x28, 0xb4, 0x74, 0xdc, 0xb1, 0x03, 0x22,
	0x4a, 0x2a, 0x3d, 0x8e, 0x73, 0x9e, 0xb9, 0x4a, 0x85, 0xfc, 0x1f, 0x3a, 0x11, 0x0f, 0x66, 0x99,
	0x3f, 0x5e, 0x11, 0xca, 0x6b, 0x5a, 0xf9, 0x84, 0x07, 0xe2, 0x1f, 0x95, 0x58, 0x29, 0x46, 0x99,
	0x3f, 0xee, 0xde, 0xac, 0x18, 0x65, 0x3e, 0xd9, 0x83, 0x4e, 0xe2, 0x85, 0x01, 0xe3, 0xe3, 0x9e,
	0x50, 0x24, 0x5a, 0xd1, 0x15, 0x5c, 0xa9, 0x2b, 0x35, 0xe8, 0xd7, 0x30, 0x7c, 0xce, 0x32, 0xe9,
	0x97, 0x4e, 0xbc, 0xd1, 0x1b, 0x8e, 0xd5, 0x1b, 0x64, 0x07, 0xfa, 0x73, 0xef, 0x7a, 0x2a, 0x53,
	0x93, 0x8a, 0x58, 0xde, 0x72, 0x4d, 0x16, 0xcd, 0x61, 0x64, 0xe0, 0xa9, 0xec, 0x3c, 0x82, 0x3e,
	0x86, 0x6d, 0xaa, 0x82, 0xe2, 0x08, 0xaf, 0x06, 0x76, 0x50, 0x5c, 0x53, 0x85, 0x1c, 0x00, 0xc4,
	0x57, 0x5c, 0x1f, 0x68, 0xd4, 0x1e, 0x30, 0x34, 0xe8, 0x48, 0x94, 0xc4, 0x29, 0x46, 0x5f, 0x97,
	0xc9, 0x27, 0xe2, 0xcf, 0x14, 0x4b, 0x39, 0x42, 0xa1, 0x2d, 0x53, 0xe6, 0xec, 0x34, 0x77, 0xfb,
	0x47, 0xab, 0x1a, 0x11, 0xb5, 0x5c, 0x29, 0xa2, 0x04, 0x86, 0x27, 0x61, 0x9a, 0x9d, 0xb2, 0x32,
	0x22, 0xd8, 0x87, 0x06, 0xcf, 0x00, 0x63, 0xac, 0x06, 0x8c, 0x31, 0x04, 0x43, 0x11, 0xfd, 0x1e,
	0xfa, 0x27, 0x3c, 0x50, 0x33, 0x30, 0xc5, 0x22, 0xf7, 0xfc, 0x2c, 0xbc, 0x94, 0x43, 0xaf, 0xed,
	0x2a, 0x0a, 0xc7, 0x45, 0xc8, 0x95, 0xa4, 0x21, 0x24, 0x05, 0x2d, 0xb2, 0x21, 0x67, 0xde, 0xb8,
	0x29, 0x44, 0x9a, 0xa4, 0xbf, 0x38, 0xb0, 0xa2, 0x72, 0x4f, 0x36, 0xa0, 0xcd, 0x92, 0x24, 0x4e,
	0x54, 0xc6, 0x24, 0x41, 0x0e, 0xa1, 0xeb, 0x2b, 0xdb, 0xd5, 0xde, 0x34, 0xdc, 0x72, 0x0b, 0x25,
	0x74, 0xd0, 0x3f, 0xf7, 0x42, 0xae, 0x7b, 0x41, 0x51, 0x98, 0xf8, 0x59, 0x14, 0xfb, 0x17, 0xe7,
	0x2c, 0x7c, 0x7d, 0x9e, 0xa9, 0x7e, 0x30, 0x59, 0x45, 0x0f, 0xb5, 0x8d, 0x1e, 0x32, 0xba, 0xb2,
	0x63, 0x75, 0x25, 0xfd, 0xd3, 0x81, 0xb6, 0x48, 0x23, 0x3a, 0xbe, 0x48, 0x42, 0x75, 0x0d, 0x38,
	0xae, 0x24, 0x30, 0x20, 0x6f, 0x72, 0x8f, 0x67, 0x61, 0x26, 0x3b, 0xd6, 0x71, 0x0b, 0xda, 0x2c,
	0xcf, 0xa6, 0x5d, 0x9e, 0xf7, 0x60, 0x55, 0x14, 0x91, 0xee, 0xf5, 0x96, 0x12, 0x33, 0x39, 0xf3,
	0x07, 0xd0, 0x08, 0x03, 0xd1, 0xad, 0x3d, 0xb7, 0x11, 0x06, 0x68, 0x24, 0x8a, 0x7d, 0x2f, 0x42,
	0x24, 0xe9, 0x5f, 0x41, 0x93, 0xfb, 0x00, 0x7e, 0xc2, 0xbc, 0x8c, 0x05, 0x53, 0x2f, 0x13, 0x9d,
	0xd9, 0x74, 0x0d, 0x0e, 0x3a, 0x11, 0xf2, 0xcb, 0x18, 0x1d, 0xef, 0x4a, 0x2b, 0x8a, 0xb4, 0x2e,
	0x8a, 0x5e, 0xe5, 0xa2, 0x38, 0x87, 0x8e, 0x2c, 0x5e, 0xf2, 0x10, 0x60, 0x96, 0xbf, 0x2d, 0x3b,
	0x02, 0x2b, 0xe8, 0x96, 0x55, 0xe0, 0xae, 0xa1, 0x40, 0x0e, 0xa1, 0x9f, 0xb2, 0x28, 0x2a, 0x1b,
	0xa2, 0x46, 0xdf, 0xd4, 0xa0, 0x2f, 0x00, 0x04, 0xf7, 0x2b, 0x2f, 0xf3, 0xcf, 0xc9, 0x03, 0x68,
	0xcf, 0xbd, 0x0b, 0x96, 0xa8, 0xd6, 0xab, 0x1c, 0x94, 0x32, 0x54, 0xca, 0x84, 0x52, 0xa3, 0x56,
	0x49, 0xc8, 0xe8, 0x13, 0xe8, 0x1b, 0x43, 0x0c, 0xb3, 0x8e, 0xd1, 0x55, 0xe5, 0x2c, 0xbe, 0xc9,
	0x10, 0x9a, 0xf1, 0x15, 0x57, 0x75, 0x8c, 0x9f, 0xf4, 0x27, 0x07, 0x5a, 0xd8, 0x62, 0x2a, 0x03,
	0x4e, 0x91, 0x81, 0xff, 0xc2, 0xad, 0x99, 0x97, 0xb2, 0x69, 0xb1, 0x40, 0xc8, 0xe9, 0x6c, 0x33,
	0xf1, 0x22, 0x7a, 0x93, 0xc7, 0x99, 0xa1, 0x26, 0xf3, 0x5e, 0xe1, 0x22, 0x5a, 0x7a, 0xe5, 0x2d,
	0xa6, 0x62, 0x61, 0xf1, 0xe3, 0x48, 0xe5, 0xdf, 0x66, 0xd2, 0x5f, 0xd1, 0x19, 0xf4, 0x73, 0x0c,
	0x2b, 0xf6, 0xc5, 0xa6, 0xc9, 0x7f, 0x74, 0x67, 0x88, 0x02, 0x98, 0xc5, 0x39, 0x97, 0x55, 0xd8,
	0x75, 0x35, 0x29, 0x2a, 0x5a, 0x0c, 0x99, 0x96, 0x68, 0x05, 0x49, 0x60, 0x07, 0x5d, 0xe7, 0xc1,
	0x54, 0xf7, 0x83, 0xac, 0x42, 0x93, 0x45, 0xf6, 0x61, 0x94, 0x32, 0x3f, 0xe6, 0x41, 0x3a, 0x55,
	0x17, 0x37, 0x93, 0x75, 0xd9, 0x76, 0x97, 0x05, 0xf4, 0x1d, 0x8c, 0x4e, 0x23, 0xcf, 0x67, 0xd6,
	0xc6, 0xf3, 0x6f, 0x36, 0x93, 0xb9, 0x3d, 0xb5, 0xec, 0xed, 0x89, 0xbe, 0x03, 0x62, 0x1a, 0x57,
	0x03, 0x71, 0x1f, 0x56, 0xe6, 0x58, 0x6e, 0x4c, 0x17, 0x34, 0xb1, 0x4a, 0x48, 0x94, 0xa2, 0xab,
	0x55, 0xc8, 0x53, 0x58, 0x4b, 0xd8, 0xdc, 0x0b, 0xb9, 0xd8, 0xe6, 0x50, 0xa1, 0xbe, 0xf0, 0xaa,
	0x5a, 0x34, 0x01, 0x28, 0x2f, 0xb2, 0x1b, 0x06, 0x9f, 0x91, 0xdb, 0x86, 0x9d, 0xdb, 0x89, 0x31,
	0x12, 0xe5, 0x3c, 0x2d, 0xa7, 0x9f, 0x31, 0xaf, 0x5a, 0xf6, 0xbc, 0xfa, 0xc3, 0x81, 0xbe, 0xb1,
	0xcd, 0x60, 0xdd, 0x27, 0x71, 0xc4, 0x94, 0x51, 0xf1, 0x8d, 0x65, 0x9a, 0xaa, 0xe5, 0xd4, 0x9b,
	0x63, 0x77, 0x08, 0xd3, 0x2d, 0xb7, 0xc2, 0x15, 0x65, 0xaa, 0x38, 0x59, 0x7c, 0xc1, 0xb8, 0x0a,
	0xbc, 0xcd, 0x24, 0x7b, 0x30, 0x4c, 0x98, 0xcf, 0xc2, 0x4b, 0x03, 0xaf, 0x25, 0xf0, 0x96, 0xf8,
	0x64, 0x17, 0x43, 0xa9, 0x79, 0x12, 0x53, 0xd6, 0x57, 0x95, 0xbd, 0x54, 0xd9, 0x9d, 0x9a, 0xdd,
	0x71, 0x04, 0x6b, 0x67, 0xe7, 0x79, 0x16, 0xc4, 0x57, 0x5c, 0xdf, 0x7f, 0x7b, 0x30, 0x2c, 0x59,
	0x1f, 0x58, 0xd8, 0xee, 0xc2, 0xe4, 0x2c, 0x9f, 0xa5, 0x7e, 0x12, 0xce, 0x18, 0xf6, 0x99, 0xb5,
	0x5b, 0xd0, 0x67, 0x70, 0xa7, 0x56, 0xaa, 0x40, 0x1f, 0x40, 0x5b, 0x96, 0x42, 0xfd, 0xa0, 0x92,
	0x05, 0xb0, 0x05, 0xb7, 0x0b, 0x0c, 0x4c, 0x4a, 0x01, 0x7e, 0x00, 0x9b, 0x55, 0x81, 0xc2, 0xdd,
	0x30, 0x71, 0x7b, 0x0a, 0xe8, 0xe8, 0x7d, 0x0f, 0x9a, 0xdf, 0xe5, 0x01, 0x99, 0x41, 0xdf, 0x58,
	0xf9, 0xc9, 0x44, 0x5b, 0x5d, 0x7e, 0x53, 0x4c, 0xee, 0xd4, 0xca, 0xa4, 0x15, 0x3a, 0xf9, 0xf1,
	0xf7, 0xf7, 0x3f, 0x37, 0x36, 0xe8, 0xda, 0xe1, 0xe5, 0xe3, 0x43, 0x39, 0xf4, 0x85, 0xa1, 0x4f,
	0x9d, 0x3d, 0x72, 0x01, 0x03, 0xfb, 0x29, 0x44, 0xee, 0x15, 0x50, 0x75, 0xef, 0xaa, 0xc9, 0xfd,
	0x9b, 0xc4, 0xb6, 0x31, 0x42, 0x84, 0x31, 0xa9, 0xa3, 0xdf, 0x50, 0x2e, 0xac, 0xa8, 0x27, 0x06,
	0xd9, 0x2c, 0x60, 0xac, 0x57, 0xc4, 0x64, 0x6b, 0x89, 0xaf, 0x70, 0x37, 0x05, 0xee, 0x90, 0xf6,
	0x05, 0xae, 0x14, 0xe2, 0x0f, 0xbc, 0x04, 0x28, 0x9f, 0x14, 0x64, 0x5b, 0x1f, 0x5f, 0x7a, 0x9f,
	0x4c, 0x26, 0x75, 0x22, 0x05, 0xbe, 0x2d, 0xc0, 0xd7, 0xe9, 0x00, 0xc1, 0x83, 0x42, 0x8e, 0xf8,
	0x33, 0xe8, 0x1b, 0xef, 0x82, 0x32, 0x09, 0xcb, 0x2f, 0x93, 0x32, 0x09, 0x35, 0x0f, 0x09, 0x3b,
	0x09, 0x4c, 0x2a, 0xe0, 0x0d, 0x80, 0x36, 0x4e, 0x60, 0x45, 0xbd, 0x1c, 0xca, 0xb8, 0xd8, 0xaf,
	0x8b, 0x32, 0x2e, 0x95, 0x27, 0x06, 0x1d, 0x0a, 0x5c, 0x20, 0x5d, 0xc4, 0x0d, 0x11, 0xe2, 0x14,
	0xba, 0x7a, 0xc3, 0x24, 0xe6, 0x31, 0x73, 0x0d, 0x9d, 0x8c, 0x97, 0x05, 0x0a, 0x70, 0x24, 0x00,
	0xfb, 0xa4, 0x87, 0x80, 0xf2, 0x92, 0xf8, 0x16, 0x7a, 0xc5, 0xf6, 0x4c, 0xcc, 0x93, 0x56, 0x13,
	0x4d, 0xb6, 0x6b, 0x24, 0x0a, 0x94, 0x08, 0xd0, 0x55, 0x02, 0x08, 0xaa, 0x96, 0x87, 0x33, 0xe8,
	0x15, 0xdb, 0x6b, 0x89, 0x5a, 0x5d, 0x72, 0x4b, 0xd4, 0xa5, 0x55, 0xb7, 0xe2, 0xaa, 0xc0, 0x79,
	0x09, 0x50, 0x5e, 0x01, 0x65, 0x39, 0x2c, 0xdd, 0x49, 0x65, 0x39, 0x2c, 0xdf, 0x18, 0x76, 0x39,
	0x2c, 0x50, 0x5e, 0xf4, 0xcb, 0x0b, 0xe8, 0xea, 0x91, 0x53, 0x06, 0xb7, 0x32, 0x97, 0xca, 0xe0,
	0x56, 0xa7, 0x13, 0xdd, 0x12, 0xc8, 0x23, 0xba, 0x8a, 0xc8, 0xa9, 0x92, 0x22, 0xee, 0x0f, 0x0e,
	0xac, 0xd7, 0x4c, 0x20, 0x42, 0x0b, 0xa8, 0x1b, 0x87, 0xd7, 0xe4, 0xc1, 0xdf, 0xea, 0x28, 0xcb,
	0xff, 0x11, 0x96, 0xb7, 0xc9, 0x96, 0xb0, 0xac, 0x15, 0x31, 0x68, 0x32, 0x1d, 0x8f, 0x1c, 0x32,
	0x87, 0x81, 0x3d, 0xa7, 0xca, 0x59, 0x50, 0x3b, 0xd8, 0xca, 0x59, 0x50, 0x3f, 0xde, 0xec, 0x59,
	0x50, 0xd8, 0xc4, 0xaa, 0x4f, 0x1f, 0x39, 0xb3, 0x8e, 0xd8, 0x7d, 0x9e, 0xfc, 0x15, 0x00, 0x00,
	0xff, 0xff, 0xcf, 0x5a, 0x57, 0xe2, 0xec, 0x11, 0x00, 0x00,
}
